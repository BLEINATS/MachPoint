import React, { useState, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useParams, Link, useNavigate } from 'react-router-dom';
import { ArrowLeft, Save, Trash2, CheckCircle, PartyPopper, List, CreditCard, Edit, Loader2 } from 'lucide-react';
import { useAuth } from '../context/AuthContext';
import Layout from '../components/Layout/Layout';
import Button from '../components/Forms/Button';
import { Evento, Quadra, Reserva, Aluno } from '../types';
import EventoModal from '../components/Eventos/EventoModal';
import VisaoGeralTab from '../components/Eventos/VisaoGeralTab';
import ChecklistTab from '../components/Eventos/ChecklistTab';
import FinanceiroTab from '../components/Eventos/FinanceiroTab';
import { eachDayOfInterval, format } from 'date-fns';
import { parseDateStringAsLocal } from '../utils/dateUtils';
import { supabase } from '../lib/supabaseClient';
import { useToast } from '../context/ToastContext';

type TabType = 'overview' | 'checklist' | 'financial';

const EventoDetail: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const { arena } = useAuth();
  const { addToast } = useToast();
  
  const [evento, setEvento] = useState<Evento | null>(null);
  const [quadras, setQuadras] = useState<Quadra[]>([]);
  const [reservas, setReservas] = useState<Reserva[]>([]);
  const [alunos, setAlunos] = useState<Aluno[]>([]);
  
  const [activeTab, setActiveTab] = useState<TabType>('overview');
  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);
  const [isModalOpen, setIsModalOpen] = useState(false);

  const loadData = useCallback(async () => {
    if (arena && id) {
      setIsLoading(true);
      try {
        const [eventoRes, quadrasRes, reservasRes, alunosRes] = await Promise.all([
          supabase.from('eventos').select('*').eq('id', id).single(),
          supabase.from('quadras').select('*, pricing_rules(*)').eq('arena_id', arena.id),
          supabase.from('reservas').select('*').eq('arena_id', arena.id),
          supabase.from('alunos').select('*').eq('arena_id', arena.id),
        ]);

        if (eventoRes.error) throw eventoRes.error;
        if (quadrasRes.error) throw quadrasRes.error;
        if (reservasRes.error) throw reservasRes.error;
        if (alunosRes.error) throw alunosRes.error;

        const eventWithChecklist = {
          ...eventoRes.data,
          checklist: eventoRes.data.checklist || [],
        };
        setEvento(eventWithChecklist);
        setQuadras(quadrasRes.data || []);
        setReservas(reservasRes.data || []);
        setAlunos(alunosRes.data || []);
      } catch (error: any) {
        console.error("Erro ao carregar detalhes do evento:", error);
        addToast({ message: `Evento não encontrado: ${error.message}`, type: 'error' });
        navigate('/eventos');
      } finally {
        setIsLoading(false);
      }
    } else {
      setIsLoading(false);
    }
  }, [arena, id, navigate, addToast]);

  useEffect(() => {
    loadData();
  }, [loadData]);
  
  const handleSave = async (eventoToSave: Evento) => {
    if (!arena) return;

    try {
      const { data: savedEvento, error: upsertError } = await supabase
        .from('eventos')
        .upsert(eventoToSave)
        .select()
        .single();
        
      if (upsertError) throw upsertError;
      if (!savedEvento) throw new Error("Falha ao salvar o evento.");
      
      setEvento(savedEvento);

      // --- SYNC LOGIC ---
      const { error: deleteError } = await supabase.from('reservas').delete().eq('evento_id', savedEvento.id);
      if (deleteError) console.error("Erro ao deletar reservas antigas do evento:", deleteError);

      if (
        (savedEvento.status === 'confirmado' || savedEvento.status === 'realizado') &&
        savedEvento.include_court_reservation &&
        savedEvento.quadras_ids && savedEvento.quadras_ids.length > 0
      ) {
        const eventBlockReservations: Omit<Reserva, 'id' | 'created_at'>[] = [];
        const eventDays = eachDayOfInterval({
          start: parseDateStringAsLocal(savedEvento.startDate),
          end: parseDateStringAsLocal(savedEvento.endDate),
        });

        for (const day of eventDays) {
          for (const quadraId of savedEvento.quadras_ids) {
            eventBlockReservations.push({
              arena_id: arena.id,
              quadra_id: quadraId,
              evento_id: savedEvento.id,
              date: format(day, 'yyyy-MM-dd'),
              start_time: savedEvento.court_start_time || savedEvento.startTime,
              end_time: savedEvento.court_end_time || savedEvento.endTime,
              type: 'evento',
              status: 'confirmada',
              clientName: `Evento: ${savedEvento.name}`,
              isRecurring: false,
              profile_id: null,
            });
          }
        }
        
        if (eventBlockReservations.length > 0) {
          const { error: insertError } = await supabase.from('reservas').insert(eventBlockReservations);
          if (insertError) console.error("Erro ao criar reservas para o evento:", insertError);
        }
      }
      // --- END SYNC LOGIC ---
      
      await loadData();
    } catch (error: any) {
        addToast({ message: `Erro ao salvar: ${error.message}`, type: 'error' });
        throw error;
    }
  };
  
  const handleSaveAndCloseModal = async (eventoData: Evento) => {
    setIsSaving(true);
    try {
      await handleSave(eventoData);
      setIsModalOpen(false);
    } catch (error) {
      // Error is already toasted in handleSave
    } finally {
      setIsSaving(false);
    }
  };

  const handleSaveFromButton = async () => {
    if (!evento) return;
    setIsSaving(true);
    try {
      await handleSave(evento);
      setShowSuccess(true);
      setTimeout(() => setShowSuccess(false), 2000);
    } catch (error) {
      // Error is already toasted in handleSave
    } finally {
      setIsSaving(false);
    }
  }
  
  const handleDelete = async () => {
    if (!arena || !evento || !window.confirm("Tem certeza que deseja excluir este evento? Esta ação não pode ser desfeita.")) return;
    
    // Remove reservations before deleting the event
    const { error: deleteReservaError } = await supabase.from('reservas').delete().eq('evento_id', evento.id);
    if (deleteReservaError) {
        addToast({ message: `Erro ao limpar reservas do evento: ${deleteReservaError.message}`, type: 'error' });
    }

    const { error: deleteEventoError } = await supabase.from('eventos').delete().eq('id', evento.id);
    if (deleteEventoError) {
        addToast({ message: `Erro ao excluir evento: ${deleteEventoError.message}`, type: 'error' });
        return;
    }

    addToast({ message: "Evento excluído com sucesso.", type: 'success' });
    navigate('/eventos');
  };

  const tabs: { id: TabType; label: string; icon: React.ElementType }[] = [
    { id: 'overview', label: 'Visão Geral', icon: PartyPopper },
    { id: 'checklist', label: 'Checklist', icon: List },
    { id: 'financial', label: 'Financeiro', icon: CreditCard },
  ];

  const renderContent = () => {
    if (!evento) return null;
    switch (activeTab) {
      case 'overview': return <VisaoGeralTab evento={evento} quadras={quadras} />;
      case 'checklist': return <ChecklistTab evento={evento} setEvento={setEvento} />;
      case 'financial': return <FinanceiroTab evento={evento} setEvento={setEvento} />;
      default: return null;
    }
  };

  if (isLoading) {
    return <Layout><div className="flex justify-center items-center h-64"><Loader2 className="w-8 h-8 text-brand-blue-500 animate-spin" /></div></Layout>;
  }

  if (!evento) {
    return (
      <Layout>
        <div className="text-center p-8">
          <h2 className="text-xl font-bold">Evento não encontrado</h2>
          <p className="mt-2 text-brand-gray-500">O evento que você procura pode ter sido removido.</p>
          <Button onClick={() => navigate('/eventos')} className="mt-4">Voltar</Button>
        </div>
      </Layout>
    );
  }

  return (
    <Layout>
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <motion.div initial={{ opacity: 0, y: -20 }} animate={{ opacity: 1, y: 0 }} className="mb-8">
          <Link to="/eventos" className="inline-flex items-center text-sm font-medium text-brand-gray-600 dark:text-brand-gray-400 hover:text-brand-blue-500 dark:hover:text-brand-blue-400 transition-colors mb-4">
            <ArrowLeft className="h-4 w-4 mr-2" />
            Voltar para o Painel de Eventos
          </Link>
          <div className="flex flex-col sm:flex-row justify-between sm:items-center gap-4">
            <div>
              <h1 className="text-3xl font-bold text-brand-gray-900 dark:text-white">{evento.name}</h1>
              <p className="text-brand-gray-600 dark:text-brand-gray-400 mt-2">Gerencie todos os detalhes do evento privado.</p>
            </div>
            <div className="flex items-center gap-2">
                <Button variant="outline" onClick={() => setIsModalOpen(true)}>
                    <Edit className="h-4 w-4 mr-2" />
                    Editar
                </Button>
                <Button onClick={handleSaveFromButton} isLoading={isSaving} disabled={isSaving}>
                  <AnimatePresence mode="wait" initial={false}>
                    <motion.span key={showSuccess ? 'success' : 'save'} initial={{ opacity: 0, y: -10 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: 10 }} className="flex items-center">
                      {showSuccess ? <><CheckCircle className="h-4 w-4 mr-2" /> Salvo!</> : <><Save className="h-4 w-4 mr-2" /> Salvar Alterações</>}
                    </motion.span>
                  </AnimatePresence>
                </Button>
            </div>
          </div>
        </motion.div>

        <div className="border-b border-brand-gray-200 dark:border-brand-gray-700 mb-8">
          <nav className="-mb-px flex space-x-6 overflow-x-auto" aria-label="Tabs">
            {tabs.map(tab => (
              <button key={tab.id} onClick={() => setActiveTab(tab.id)} className={`whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm flex items-center transition-colors ${activeTab === tab.id ? 'border-brand-blue-500 text-brand-blue-600 dark:text-brand-blue-400' : 'border-transparent text-brand-gray-500 hover:text-brand-gray-700 hover:border-brand-gray-300 dark:text-brand-gray-400 dark:hover:text-brand-gray-200 dark:hover:border-brand-gray-600'}`}>
                <tab.icon className="mr-2 h-5 w-5" />
                {tab.label}
              </button>
            ))}
          </nav>
        </div>

        <AnimatePresence mode="wait">
          <motion.div key={activeTab} initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -20 }}>
            {renderContent()}
          </motion.div>
        </AnimatePresence>
      </div>
      
      <EventoModal 
        isOpen={isModalOpen} 
        onClose={() => setIsModalOpen(false)} 
        onSave={handleSaveAndCloseModal} 
        initialData={evento}
        quadras={quadras}
        reservas={reservas}
        alunos={alunos}
      />
    </Layout>
  );
};

export default EventoDetail;
