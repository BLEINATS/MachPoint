import React, { useState, useEffect, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { X, Save, User, Calendar, Clock, Users, DollarSign, Plus, Trash2, Info, Home, AlertCircle } from 'lucide-react';
import { Evento, Quadra, EventoTipoPrivado, EventoStatus, Reserva, PricingRule, Aluno } from '../../types';
import Button from '../Forms/Button';
import Input from '../Forms/Input';
import { format, parse, isSameDay, isBefore, eachDayOfInterval, getDay, addDays, addMinutes } from 'date-fns';
import { maskPhone } from '../../utils/masks';
import { expandRecurringReservations } from '../../utils/reservationUtils';
import { parseDateStringAsLocal } from '../../utils/dateUtils';
import { ToggleSwitch } from '../Gamification/ToggleSwitch';
import { v4 as uuidv4 } from 'uuid';

interface EventoModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (evento: Evento) => Promise<void>;
  initialData: Evento | null;
  quadras: Quadra[];
  reservas: Reserva[];
  alunos: Aluno[];
}

const timeToMinutes = (timeStr: string): number => {
  if (!timeStr || !timeStr.includes(':')) return -1;
  try {
    const [hours, minutes] = timeStr.split(':').map(Number);
    if (isNaN(hours) || isNaN(minutes)) return -1;
    return hours * 60 + minutes;
  } catch (e) {
    return -1;
  }
};

const findMatchingRule = (
  rules: PricingRule[],
  sport: string,
  date: string,
  startTime: string,
  isMonthlyCustomer: boolean
): { rule: PricingRule | null } => {
  const reservationDay = getDay(parseDateStringAsLocal(date));
  const reservationStartTimeMinutes = timeToMinutes(startTime);

  const applicableRules = rules.filter(rule => {
    const ruleStartMinutes = timeToMinutes(rule.start_time);
    let ruleEndMinutes = timeToMinutes(rule.end_time);
    if (ruleEndMinutes === 0 && rule.end_time === '00:00') ruleEndMinutes = 24 * 60;

    let match = false;
    if (ruleStartMinutes < ruleEndMinutes) {
      match = reservationStartTimeMinutes >= ruleStartMinutes && reservationStartTimeMinutes < ruleEndMinutes;
    } else {
      match = reservationStartTimeMinutes >= ruleStartMinutes || reservationStartTimeMinutes < ruleEndMinutes;
    }
    
    return rule.is_active &&
      rule.days_of_week.includes(reservationDay) &&
      (rule.sport_type === sport || rule.sport_type === 'Qualquer Esporte') &&
      match;
  });

  const specificSportRule = applicableRules.find(r => r.sport_type === sport && !r.is_default);
  const anySportRule = applicableRules.find(r => r.sport_type === 'Qualquer Esporte' && !r.is_default);
  const defaultSpecificSportRule = applicableRules.find(r => r.sport_type === sport && r.is_default);
  const defaultAnySportRule = applicableRules.find(r => r.sport_type === 'Qualquer Esporte' && r.is_default);

  const targetRule = specificSportRule || anySportRule || defaultSpecificSportRule || defaultAnySportRule || null;

  return { rule: targetRule };
};

const defaultChecklistItems = [
  'Confirmar pagamento do sinal',
  'Enviar contrato para o cliente',
  'Definir layout do evento (mesas, cadeiras, etc.)',
  'Contratar buffet (se aplicável)',
  'Contratar decoração (se aplicável)',
  'Verificar lista de convidados',
  'Agendar equipe de limpeza pós-evento',
  'Confirmar pagamento final antes do evento',
];


const EventoModal: React.FC<EventoModalProps> = ({ isOpen, onClose, onSave, initialData, quadras, reservas, alunos }) => {
  const [formData, setFormData] = useState({
    name: '',
    type: 'festa' as EventoTipoPrivado,
    status: 'orcamento' as EventoStatus,
    clientName: '',
    clientPhone: '',
    clientEmail: '',
    startDate: format(new Date(), 'yyyy-MM-dd'),
    endDate: format(new Date(), 'yyyy-MM-dd'),
    startTime: '18:00',
    endTime: '23:00',
    expectedGuests: 50,
    quadras_ids: [] as string[],
    additionalSpaces: [] as string[],
    services: [] as { name: string; price: string; included: boolean }[],
    depositValue: '',
    paymentConditions: '50% de sinal, restante no dia do evento.',
    notes: '',
    include_court_reservation: false,
    court_start_time: '19:00',
    court_end_time: '21:00',
  });
  const [conflictWarning, setConflictWarning] = useState<string | null>(null);
  const [isSaving, setIsSaving] = useState(false);

  const isEditing = !!initialData;

  const selectedClient = useMemo(() => {
    if (!formData.clientName) return null;
    return alunos.find(a => a.name.toLowerCase() === formData.clientName.toLowerCase());
  }, [formData.clientName, alunos]);

  const totalValue = useMemo(() => {
    const servicesCost = formData.services.reduce((sum, service) => {
      const price = parseFloat(String(service.price).replace(',', '.')) || 0;
      return sum + (service.included ? 0 : price);
    }, 0);

    const isMonthlyCustomer = !!(selectedClient && selectedClient.monthly_fee && selectedClient.monthly_fee > 0);

    let quadrasCost = 0;
    if (formData.include_court_reservation && formData.quadras_ids.length > 0 && formData.startDate && formData.endDate && formData.court_start_time && formData.court_end_time) {
      try {
        const eventStartDate = parseDateStringAsLocal(formData.startDate);
        const eventEndDate = parseDateStringAsLocal(formData.endDate);
        if (isBefore(eventEndDate, eventStartDate)) return servicesCost;

        const eventDays = eachDayOfInterval({ start: eventStartDate, end: eventEndDate });

        for (const day of eventDays) {
          for (const quadraId of formData.quadras_ids) {
            const quadra = quadras.find(q => q.id === quadraId);
            if (!quadra || !quadra.pricing_rules) continue;

            const start = parse(formData.court_start_time, 'HH:mm', day);
            let end = parse(formData.court_end_time, 'HH:mm', day);
            if (end <= start) end = addDays(end, 1);

            let currentTime = start;
            const intervalMinutes = 30;

            while (isBefore(currentTime, end)) {
              const segmentStartTimeStr = format(currentTime, 'HH:mm');
              const segmentDateStr = format(currentTime, 'yyyy-MM-dd');
              
              const sportType = quadra.sports?.[0] || 'Qualquer Esporte';
              const { rule } = findMatchingRule(quadra.pricing_rules, sportType, segmentDateStr, segmentStartTimeStr, isMonthlyCustomer);
              
              const pricePerHour = rule ? (isMonthlyCustomer ? rule.price_monthly : rule.price_single) : 0;
              const segmentPrice = pricePerHour * (intervalMinutes / 60);
              quadrasCost += segmentPrice;
              
              currentTime = addMinutes(currentTime, intervalMinutes);
            }
          }
        }
      } catch (e) {
        console.error("Erro ao calcular custo das quadras:", e);
        return servicesCost;
      }
    }

    return quadrasCost + servicesCost;
  }, [formData.services, formData.include_court_reservation, formData.quadras_ids, formData.startDate, formData.endDate, formData.court_start_time, formData.court_end_time, quadras, selectedClient]);


  // Conflict checking logic
  useEffect(() => {
    if (!isOpen || !formData.include_court_reservation || !formData.quadras_ids.length || !formData.startDate || !formData.endDate || !formData.court_start_time || !formData.court_end_time) {
      setConflictWarning(null);
      return;
    }

    const checkConflicts = () => {
      const eventStartDate = parseDateStringAsLocal(formData.startDate);
      const eventEndDate = parseDateStringAsLocal(formData.endDate);

      if (isBefore(eventEndDate, eventStartDate)) {
        setConflictWarning("A data de fim não pode ser anterior à data de início.");
        return;
      }

      const allExpandedReservations = expandRecurringReservations(reservas, eventStartDate, eventEndDate, quadras);
      const eventDays = eachDayOfInterval({ start: eventStartDate, end: eventEndDate });

      for (const day of eventDays) {
        for (const quadraId of formData.quadras_ids) {
          const conflictingReserva = allExpandedReservations.find(r => {
            if (isEditing && (r.evento_id === initialData?.id)) return false;
            if (r.quadra_id !== quadraId || !isSameDay(parseDateStringAsLocal(r.date), day) || r.status === 'cancelada') {
              return false;
            }

            const eventStartTime = parse(formData.court_start_time!, 'HH:mm', day);
            const eventEndTime = parse(formData.court_end_time!, 'HH:mm', day);
            const reservaStartTime = parse(r.start_time, 'HH:mm', day);
            const reservaEndTime = parse(r.end_time, 'HH:mm', day);
            
            return eventStartTime < reservaEndTime && eventEndTime > reservaStartTime;
          });

          if (conflictingReserva) {
            const quadra = quadras.find(q => q.id === quadraId);
            setConflictWarning(`Conflito em ${format(day, 'dd/MM')}: A quadra "${quadra?.name}" já tem uma reserva (${conflictingReserva.clientName}) das ${conflictingReserva.start_time} às ${conflictingReserva.end_time}.`);
            return;
          }
        }
      }
      setConflictWarning(null);
    };

    checkConflicts();
  }, [formData.include_court_reservation, formData.quadras_ids, formData.startDate, formData.endDate, formData.court_start_time, formData.court_end_time, reservas, quadras, isEditing, initialData?.id, isOpen]);


  useEffect(() => {
    if (!isOpen) return;

    if (initialData) {
      setFormData({
        name: initialData.name,
        type: initialData.type,
        status: initialData.status,
        clientName: initialData.clientName,
        clientPhone: initialData.clientPhone,
        clientEmail: initialData.clientEmail,
        startDate: initialData.startDate,
        endDate: initialData.endDate,
        startTime: initialData.startTime,
        endTime: initialData.endTime,
        expectedGuests: initialData.expectedGuests,
        quadras_ids: initialData.quadras_ids || [],
        additionalSpaces: initialData.additionalSpaces || [],
        services: initialData.services.map(s => ({ ...s, price: String(s.price).replace('.', ',') })),
        depositValue: String(initialData.depositValue).replace('.', ','),
        paymentConditions: initialData.paymentConditions,
        notes: initialData.notes,
        include_court_reservation: initialData.include_court_reservation ?? (initialData.quadras_ids && initialData.quadras_ids.length > 0),
        court_start_time: initialData.court_start_time || initialData.startTime || '19:00',
        court_end_time: initialData.court_end_time || initialData.endTime || '21:00',
      });
    } else {
      setFormData({
        name: '', type: 'festa', status: 'orcamento',
        clientName: '', clientPhone: '', clientEmail: '',
        startDate: format(new Date(), 'yyyy-MM-dd'),
        endDate: format(new Date(), 'yyyy-MM-dd'),
        startTime: '18:00', endTime: '23:00', expectedGuests: 50,
        quadras_ids: [], additionalSpaces: [],
        services: [
            { name: 'Limpeza Básica', price: '150,00', included: false },
            { name: 'Segurança (1)', price: '200,00', included: false },
        ],
        depositValue: '',
        paymentConditions: '50% de sinal, restante no dia do evento.',
        notes: '',
        include_court_reservation: false,
        court_start_time: '19:00',
        court_end_time: '21:00',
      });
    }
  }, [initialData, isOpen]);

  const handleSave = async () => {
    if (conflictWarning) {
      alert(conflictWarning);
      return;
    }
    setIsSaving(true);
    try {
      const newChecklist = isEditing
        ? initialData?.checklist || []
        : defaultChecklistItems.map(text => ({ id: uuidv4(), text, completed: false }));

      const dataToSave: Evento = {
        ...(initialData || {}),
        ...formData,
        id: initialData?.id || `evento_${Date.now()}`,
        arena_id: initialData?.arena_id || '',
        created_at: initialData?.created_at || new Date().toISOString(),
        totalValue,
        services: formData.services.map(s => ({
            ...s,
            price: parseFloat(s.price.replace(',', '.')) || 0,
        })),
        depositValue: parseFloat(formData.depositValue.replace(',', '.')) || 0,
        checklist: newChecklist,
        payments: initialData?.payments || [],
      };
      await onSave(dataToSave);
    } catch (e) {
        console.error("Falha ao salvar evento no modal:", e);
    } finally {
        setIsSaving(false);
    }
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;

    if (name === 'additionalSpaces') {
        setFormData(prev => ({ ...prev, additionalSpaces: value.split(',').map(s => s.trim()) }));
        return;
    }

    if (name === 'expectedGuests') {
        setFormData(prev => ({ ...prev, expectedGuests: Number(value) }));
        return;
    }

    let finalValue = value;
    if (name === 'clientPhone') {
      finalValue = maskPhone(value);
    }
    
    setFormData(prev => ({ ...prev, [name]: finalValue }));
  };
  
  const handleServiceChange = (index: number, field: 'name' | 'price' | 'included', value: string | boolean) => {
    const newServices = [...formData.services];
    (newServices[index] as any)[field] = value;
    setFormData(p => ({ ...p, services: newServices }));
  };

  const addService = () => {
    setFormData(p => ({ ...p, services: [...p.services, { name: '', price: '0,00', included: false }] }));
  };
  
  const removeService = (index: number) => {
    setFormData(p => ({ ...p, services: p.services.filter((_, i) => i !== index) }));
  };

  const handleQuadraToggle = (quadraId: string) => {
    setFormData(prev => ({
      ...prev,
      quadras_ids: prev.quadras_ids.includes(quadraId)
        ? prev.quadras_ids.filter(id => id !== quadraId)
        : [...prev.quadras_ids, quadraId]
    }));
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50" onClick={onClose}>
          <motion.div
            initial={{ opacity: 0, scale: 0.9 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.9 }}
            className="bg-white dark:bg-brand-gray-900 rounded-lg w-full max-w-4xl shadow-xl flex flex-col max-h-[90vh]"
            onClick={e => e.stopPropagation()}
          >
            <div className="flex justify-between items-center p-6 border-b border-brand-gray-200 dark:border-brand-gray-700">
              <h3 className="text-xl font-semibold text-brand-gray-900 dark:text-white">
                {isEditing ? `Orçamento: ${formData.name}` : 'Novo Orçamento de Evento'}
              </h3>
              <button onClick={onClose} className="p-1 rounded-full hover:bg-brand-gray-100 dark:hover:bg-brand-gray-700">
                <X className="h-5 w-5 text-brand-gray-500" />
              </button>
            </div>

            <div className="p-6 space-y-6 overflow-y-auto">
              {/* Seção Cliente e Evento */}
              <Section title="Cliente e Evento">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <Input label="Nome do Evento" name="name" value={formData.name} onChange={handleChange} placeholder="Aniversário da Maria" required />
                  <FormSelect label="Tipo de Evento" name="type" value={formData.type} onChange={handleChange} options={['festa', 'corporativo', 'aniversario', 'show', 'outro']} />
                </div>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                  <Input label="Nome do Cliente" name="clientName" value={formData.clientName} onChange={handleChange} required />
                  <Input label="E-mail do Cliente" name="clientEmail" type="email" value={formData.clientEmail} onChange={handleChange} />
                  <Input label="Telefone do Cliente" name="clientPhone" value={formData.clientPhone} onChange={handleChange} />
                </div>
              </Section>
              
              {/* Seção Data e Espaços */}
              <Section title="Data e Espaços">
                 <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <Input label="Data de Início" name="startDate" type="date" value={formData.startDate} onChange={handleChange} />
                    <Input label="Data de Fim" name="endDate" type="date" value={formData.endDate} onChange={handleChange} />
                    <Input label="Início (Evento)" name="startTime" type="time" value={formData.startTime} onChange={handleChange} />
                    <Input label="Fim (Evento)" name="endTime" type="time" value={formData.endTime} onChange={handleChange} />
                 </div>
                 <Input label="Nº de Convidados" name="expectedGuests" type="number" value={formData.expectedGuests.toString()} onChange={handleChange} />
                 
                 <div className="flex items-center justify-between p-4 bg-brand-gray-50 dark:bg-brand-gray-900/50 rounded-lg">
                    <div>
                        <h4 className="font-medium text-brand-gray-900 dark:text-white">Incluir Reserva de Quadra?</h4>
                        <p className="text-sm text-brand-gray-500 dark:text-brand-gray-400">Marque para reservar quadras durante o evento.</p>
                    </div>
                    <ToggleSwitch 
                        enabled={formData.include_court_reservation} 
                        setEnabled={(value) => setFormData(p => ({ ...p, include_court_reservation: value }))} 
                    />
                </div>

                <AnimatePresence>
                {formData.include_court_reservation && (
                    <motion.div 
                        initial={{ opacity: 0, height: 0 }}
                        animate={{ opacity: 1, height: 'auto' }}
                        exit={{ opacity: 0, height: 0 }}
                        className="space-y-4 pt-4 border-t border-dashed border-brand-gray-300 dark:border-brand-gray-600 overflow-hidden"
                    >
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                            <Input label="Início (Quadra)" name="court_start_time" type="time" value={formData.court_start_time || ''} onChange={handleChange} />
                            <Input label="Fim (Quadra)" name="court_end_time" type="time" value={formData.court_end_time || ''} onChange={handleChange} />
                        </div>
                        <div>
                            <label className="block text-sm font-medium text-brand-gray-700 dark:text-brand-gray-300 mb-2">Quadras a serem utilizadas</label>
                            <div className="grid grid-cols-2 sm:grid-cols-4 gap-2">
                                {quadras.map(quadra => (
                                    <label key={quadra.id} className={`flex items-center p-3 rounded-lg border cursor-pointer transition-colors ${formData.quadras_ids.includes(quadra.id) ? 'bg-blue-50 dark:bg-blue-900/50 border-blue-300 dark:border-blue-700' : 'bg-white dark:bg-brand-gray-800 border-brand-gray-200 dark:border-brand-gray-700'}`}>
                                    <input type="checkbox" checked={formData.quadras_ids.includes(quadra.id)} onChange={() => handleQuadraToggle(quadra.id)} className="h-4 w-4 rounded text-brand-blue-600 border-brand-gray-300 focus:ring-brand-blue-500" />
                                    <span className="ml-3 text-sm font-medium text-brand-gray-800 dark:text-brand-gray-200">{quadra.name}</span>
                                    </label>
                                ))}
                            </div>
                        </div>
                    </motion.div>
                )}
                </AnimatePresence>

                 {conflictWarning && (
                    <div className="rounded-md bg-red-50 dark:bg-red-900/20 p-4">
                        <div className="flex">
                        <div className="flex-shrink-0">
                            <AlertCircle className="h-5 w-5 text-red-400" aria-hidden="true" />
                        </div>
                        <div className="ml-3">
                            <h3 className="text-sm font-medium text-red-800 dark:text-red-300">Atenção: Horário Indisponível</h3>
                            <div className="mt-2 text-sm text-red-700 dark:text-red-400">
                            <p>{conflictWarning}</p>
                            </div>
                        </div>
                        </div>
                    </div>
                )}
                 <Input 
                    label="Outros Espaços (separar por vírgula)" 
                    name="additionalSpaces" 
                    value={formData.additionalSpaces.join(', ')} 
                    onChange={handleChange}
                    placeholder="Churrasqueira, Salão de Festas"
                    icon={<Home className="h-4 w-4 text-brand-gray-400" />}
                />
              </Section>

              {/* Seção Orçamento */}
              <Section title="Orçamento e Serviços">
                <div className="space-y-2">
                  {formData.services.map((service, index) => (
                    <div key={index} className="grid grid-cols-12 gap-2 items-center">
                      <div className="col-span-6">
                        <Input placeholder="Nome do serviço" value={service.name} onChange={(e) => handleServiceChange(index, 'name', e.target.value)} />
                      </div>
                      <div className="col-span-3">
                        <Input type="text" inputMode="decimal" placeholder="Preço" value={service.price} onChange={(e) => handleServiceChange(index, 'price', e.target.value)} disabled={service.included} />
                      </div>
                      <div className="col-span-2 flex items-center justify-center">
                        <input type="checkbox" title="Serviço incluso no pacote?" checked={service.included} onChange={(e) => handleServiceChange(index, 'included', e.target.checked)} className="form-checkbox h-5 w-5 rounded text-brand-blue-600" />
                      </div>
                      <div className="col-span-1">
                        <Button variant="ghost" size="sm" onClick={() => removeService(index)} className="text-red-500"><Trash2 className="h-4 w-4" /></Button>
                      </div>
                    </div>
                  ))}
                </div>
                <Button variant="outline" size="sm" onClick={addService}><Plus className="h-4 w-4 mr-2" /> Adicionar Serviço</Button>
                <div className="text-right font-bold text-xl text-brand-gray-800 dark:text-white mt-4">
                  Valor Total: {totalValue.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}
                </div>
              </Section>
              
              <Section title="Pagamento e Observações">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <Input label="Sinal (R$)" name="depositValue" type="text" inputMode="decimal" value={formData.depositValue} onChange={handleChange} />
                    <Input label="Condições de Pagamento" name="paymentConditions" value={formData.paymentConditions} onChange={handleChange} />
                </div>
                <textarea name="notes" value={formData.notes} onChange={handleChange} placeholder="Observações e requisitos especiais do cliente..." className="w-full form-textarea rounded-md border-brand-gray-300 dark:border-brand-gray-600 bg-white dark:bg-brand-gray-800 text-brand-gray-900 dark:text-white focus:border-brand-blue-500 focus:ring-brand-blue-500" rows={3}></textarea>
              </Section>

              <div className="rounded-lg p-4 bg-blue-50 dark:bg-brand-blue-500/10 border border-blue-200 dark:border-brand-blue-500/20">
                <p className="text-sm text-blue-700 dark:text-blue-300 flex items-center">
                  <Info className="h-4 w-4 mr-2 flex-shrink-0" />
                  Ao mover o evento para "Confirmado", os horários das quadras selecionadas serão bloqueados no Hub de Reservas.
                </p>
              </div>
            </div>

            <div className="p-6 mt-auto border-t border-brand-gray-200 dark:border-brand-gray-700 flex justify-between items-center">
                <div>
                    <label className="text-sm font-medium text-brand-gray-700 dark:text-brand-gray-300 mr-2">Status:</label>
                    <select name="status" value={formData.status} onChange={handleChange} className="form-select rounded-md border-brand-gray-300 dark:border-brand-gray-600 bg-white dark:bg-brand-gray-800 text-brand-gray-900 dark:text-white focus:border-brand-blue-500 focus:ring-brand-blue-500">
                        <option value="orcamento">Orçamento</option>
                        <option value="pendente">Pendente</option>
                        <option value="confirmado">Confirmado</option>
                        <option value="realizado">Realizado</option>
                        <option value="concluido">Concluído</option>
                        <option value="cancelado">Cancelado</option>
                    </select>
                </div>
                <div className="flex gap-3">
                    <Button variant="outline" onClick={onClose}>Cancelar</Button>
                    <Button onClick={handleSave} disabled={!!conflictWarning || isSaving} isLoading={isSaving}>
                        <Save className="h-4 w-4 mr-2"/> {isEditing ? 'Salvar Alterações' : 'Criar Orçamento'}
                    </Button>
                </div>
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
};

const Section: React.FC<{ title: string; children: React.ReactNode }> = ({ title, children }) => (
    <div className="border-t border-brand-gray-200 dark:border-brand-gray-700 pt-6">
      <h4 className="text-lg font-semibold text-brand-gray-900 dark:text-white mb-4">{title}</h4>
      <div className="space-y-4">{children}</div>
    </div>
);

const FormSelect: React.FC<React.SelectHTMLAttributes<HTMLSelectElement> & { label: string, options: string[] }> = ({ label, options, ...props }) => (
  <div>
    <label className="block text-sm font-medium text-brand-gray-700 dark:text-brand-gray-300 mb-1">{label}</label>
    <select className="w-full form-select rounded-md border-brand-gray-300 dark:border-brand-gray-600 bg-white dark:bg-brand-gray-800 text-brand-gray-900 dark:text-white focus:border-brand-blue-500 focus:ring-brand-blue-500" {...props}>
      {options.map(opt => <option key={opt} value={opt}>{opt.charAt(0).toUpperCase() + opt.slice(1)}</option>)}
    </select>
  </div>
);

export default EventoModal;
